# Задание 2

В данном репозитории представлен [Ansible Playbook](https://github.com/GrigoriyAzatyan/test-task/blob/master/Task%202/site.yml), который:
- устанавливает на удаленной машине Docker и Docker Compose;
- копирует в папки на удаленной машине [скрипты и конфигурационные файлы](https://github.com/GrigoriyAzatyan/test-task/tree/master/Task%202/templates);
- собирает и запускает два контейнера с шаблонным next.js приложением: 
     - **next-app-dev** для разработки, 
     - **next-app** для продуктива.


## Как выполнены условия, поставленные в задании


### 1. dev-loop (сохранение кода вызывает пересборку)
Интересное и не до конца понятное условие. По сути (как мне удалось понять), это два разных условия:
- **dev-loop** - это обычный файл, смонтированный как файловая система;
- **сохранение кода вызывает пересборку** - это по сути самодельный CI/CD конвейер.
- Как напрямую связаны эти два условия между собой - мне не удалось понять. Поэтому данные пункты я разделил в два независимых пункта.

Примечание: возможно, я иначе понял поставленную задачу. Но обычно чем подробнее описано ТЗ, тем больше вероятности, что конечный результат
совпадет с представлениями заказчика. И обратно: чем больше общих фраз, тем больше сюрпризов в итоге ждет обе стороны, т.к. задачу "сделать, чтобы всем стало хорошо" каждый понимает по-своему.


#### 1.1. dev-loop
[Вот этот скрипт](https://github.com/GrigoriyAzatyan/test-task/blob/master/Task%202/templates/dev-loop.sh.j2) проверяет наличие в фаловой системе смонтированного устройства /dev/loop100.
- Если таковое имеется, скрипт завершает работу;
- Если нет - считаем это первоначальным запуском:
     - Создаем файл /loop_nextapp;
     - Увеличиваем его до условных 512 МБ (в нашем стенде точно больше не понадобится);
     - Создаем из этого файла петлевое устройство /dev/loop100, форматируем его в ext4 и монтируем в каталог /next-app;
     - Создаем еще ряд нужных нам в будущем каталогов;
     - Записываем в cron скрипты для автоматического монтирования loop-устройства при загрузке, а также скрипт для CI/CD "rebuild.sh", о котором речь будет ниже.

**Результат**: 
- Каталог /next-app, в котором будет работать приложение для продуктива, смонтирован как loop-устройство;
- Сохранение кода *будет* вызывать пересборку, но не в этом пункте. Не переключайте канал ;-).


### 2. Единый Dockerfile для разработки и продакшена
[Dockerfile](https://github.com/GrigoriyAzatyan/test-task/blob/master/Task%202/templates/Dockerfile.j2) здесь выдает один конечный Docker-образ, на основе которого уже Docker Compose развернет два контейнера - один для разработки, другой для продуктива.


### 3. Мультистейдж-сборка 
Выполнена [по инструкции с Хабра](https://habr.com/ru/post/349802/). 
Вкратце: 
- Собираем промежуточный образ на базе node:latest и выполняем в нем сборку кода;
- Собираем окончательный образ также на базе node:latest и копируем в него готовый код из промежуточного образа.


### 4. Эффективное кеширование на уровне докерфайла
Что я понимаю из этого: нужно добиться, чтобы в целевой Docker-образ не попал лишний мусор, чтобы он не вырос неоправданно большим и т.д.
Здесь нужно следить за слоями, как например описано в [статье](https://itchef.ru/articles/3752/).

Для этого я следую нескольким правилам:
- Никогда не компилирую в Docker, пока не посмотрю [это видео](https://www.youtube.com/watch?v=2ZkKqiEiXmc);
- Все, что может быть впоследствии поменяться (например список устанавливаемых зависимостей) - опустить в Dockerfile как можно ниже, чтобы это слой не создался дубликатом сверху уже записанного ранее;
- Чистить кэш apt/yum после установки пакетов;
- Как можно меньше RUN, чтобы также не плодить слои;
- Мультистейдж-сборка как раз позволяет выполнить все "мусорные" операции в промежуточном контейнере, а в боевой контейнер отправить только самое нужное.

   
### 5. package.lock и package-lock.json в репозитории

`ls -l /next-app/pack*`

```
-rw-r--r-- 1 root root     20 Dec 14 23:37 /next-app/package.json
-rw-r--r-- 1 root root 113558 Dec 14 23:37 /next-app/package-lock.json
```
Вот и они сами: 
- [package-lock.json](https://github.com/GrigoriyAzatyan/test-task/blob/master/Task%202/package-lock.json)
- [package.json](https://github.com/GrigoriyAzatyan/test-task/blob/master/Task%202/package.json)

   
### 6. Сохранение кода вызывает пересборку
Как я решил данную задачу:
- К обоим запущенным контейнерам монтируется локальный каталог с хостовой машины: 
     - для **next-app-dev** это /next-app-dev; 
     - для **next-app** это /next-app.
- Для обоих контейнеров внешний каталог монтируется в папку /next-app внутри контейнера. 
- При первичном запуске контейнера (docker run) примонтированная папка /next-app внутри контейнера заполняется шаблонным кодом, заранее припасенным в папке /temp.
- Таким образом, вновь созданные контейнеры уже функционируют:
     - "боевой" /next-app на порту 3000: http://46.146.220.219:3000/
     - "учебный" /next-app-dev на порту 2999: http://46.146.220.219:2999/
- В папке next-app-dev на хосте также создается служебный файл **rebuild**, служащий маркером того, что надо запустить пересборку;
- Для запуска пересборки достаточно записать любые изменения в этот файл.
- В планировщике на хосте при запуске сервера, а также разово при отработке Playbook запускается [скрипт](https://github.com/GrigoriyAzatyan/test-task/blob/master/Task%202/templates/rebuild.sh.j2), который начинает мониторить изменения в файле rebuild, и при детектировании изменений запускать пересборку.

Как выполняется пересборка:
- Прибиваются и создаются заново все контейнеры;
- Удаляется все содержимое из "боевой" папки /next-app;
- "Боевая" папка /next-app заполняется содержимым из папки для разработки: /next-app-dev;
- Запускается приложение.

Таким образом, достигнута следующая цель:
- Разработчики работают с "учебным" контейнером next-app-dev;
- При достижении некоторого результата и при желании перенести наработки в "прод", разработчик изменяет файл rebuild;
- Все изменения переносятся в боевой контейнер, и на нем запускается новая версия приложения..

**Примечание**: в начале я мониторил изменения во всей папке с "учебным" кодом, но это оказалось непрактично: изменения в любом файле сразу запускают процесс пересборки, и так - бесконечно! Поэтому было принято решение использовать для этого специальный файл, служащий "спусковым крючком" для запуска операции.


### Как запустить Playbook у себя: 

`ansible-playbook -i inventory/prod.yml site.yml`
